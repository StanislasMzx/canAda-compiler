FICHIER	::=	with Ada . Text_IO ; use Ada . Text_IO ; PROCEDURE BEGIN_INSTRUCTION ; EOF

PROCEDURE	::=	procedure ident is END_PROCEDURE
END_PROCEDURE	::=	''
END_PROCEDURE	::=	GENERATE_DECLARATIONS

BEGIN_INSTRUCTION	::=	begin GENERATE_INSTRUCTIONS end END_BEGIN_INSTRUCTION
END_BEGIN_INSTRUCTION	::=	''
END_BEGIN_INSTRUCTION	::=	ident

GENERATE_DECLARATIONS	::=	DECLARATION GENERATE_DECLARATIONS_FACTORISATION
GENERATE_DECLARATIONS_FACTORISATION	::=	GENERATE_DECLARATIONS
GENERATE_DECLARATIONS_FACTORISATION	::=	''

GENERATE_INSTRUCTIONS	::=	INSTRUCTION GENERATE_INSTRUCTIONS_FACTORISATION
GENERATE_INSTRUCTIONS_FACTORISATION	::=	''
GENERATE_INSTRUCTIONS_FACTORISATION	::=	GENERATE_INSTRUCTIONS

DECLARATION	::=	type ident DECLARATION_TYPE
DECLARATION	::=	GENERATE_IDENT : TYPE DECLARATION_WITH_EXPRESSION
DECLARATION	::=	procedure ident DECLARATION_PROCEDURE
DECLARATION	::=	function ident DECLARATION_FUNCTION

DECLARATION_TYPE	::=	;
DECLARATION_TYPE	::=	is ACCESS_RECORD

ACCESS_RECORD	::=	access ident ;
ACCESS_RECORD	::=	record GENERATE_CHAMPS end record ;

DECLARATION_WITH_EXPRESSION	::=	;
DECLARATION_WITH_EXPRESSION	::= := UNARY EXPRESSION ;

DECLARATION_PROCEDURE	::=	IS_DECLARATION BEGIN_INSTRUCTION ;
DECLARATION_PROCEDURE	::=	PARAMS IS_DECLARATION BEGIN_INSTRUCTION ;

DECLARATION_FUNCTION	::=	return TYPE IS_DECLARATION BEGIN_INSTRUCTION ;
DECLARATION_FUNCTION	::=	PARAMS return TYPE IS_DECLARATION BEGIN_INSTRUCTION ;

GENERATE_IDENT	::=	ident END_GENERATE_IDENT
END_GENERATE_IDENT	::=	, GENERATE_IDENT
END_GENERATE_IDENT	::=	''

IS_DECLARATION	::=	is IS_DECLARATION_FACTORISATION
IS_DECLARATION_FACTORISATION	::=	''
IS_DECLARATION_FACTORISATION	::=	GENERATE_DECLARATIONS

CHAMPS	::=	GENERATE_IDENT : TYPE ;
GENERATE_CHAMPS	::=	CHAMPS END_GENERATE_CHAMPS
END_GENERATE_CHAMPS	::=	GENERATE_CHAMPS
END_GENERATE_CHAMPS	::=	''

TYPE	::=	ident
TYPE	::=	access ident
PARAMS	::=	( PARAM
PARAM	::=	GENERATE_IDENT : TYPE_OR_MODE_TYPE_PARAM
TYPE_OR_MODE_TYPE_PARAM	::=	TYPE END_PARAM
TYPE_OR_MODE_TYPE_PARAM	::=	MODE TYPE END_PARAM
END_PARAM	::=	)
END_PARAM	::=	; PARAM
MODE	::=	in OUT_OR_NOT
OUT_OR_NOT	::=	''
OUT_OR_NOT	::=	out

EXPRESSION	::=	EXPRESSION_1 EXPRESSION_OR
EXPRESSION	::=	new ident EXPRESSION_OR
EXPRESSION	::=	character’val ( UNARY EXPRESSION ) EXPRESSION_OR

EXPRESSION_OR	::=	or EXPRESSION_ELSE
EXPRESSION_OR	::=	''
EXPRESSION_ELSE	::=	EXPRESSION_1 EXPRESSION_OR
EXPRESSION_ELSE	::=	else UNARY EXPRESSION_1 EXPRESSION_OR

EXPRESSION_1	::=	EXPRESSION_NOT EXPRESSION_AND
EXPRESSION_AND	::=	and EXPRESSION_THEN
EXPRESSION_AND	::=	''
EXPRESSION_THEN	::=	EXPRESSION_NOT EXPRESSION_AND
EXPRESSION_THEN	::=	then UNARY EXPRESSION_NOT EXPRESSION_AND

EXPRESSION_NOT	::=	not UNARY EXPRESSION_NOT
EXPRESSION_NOT	::=	EXPRESSION_3

EXPRESSION_3	::=	EXPRESSION_4 EXPRESSION_EQUALS
EXPRESSION_EQUALS	::=	= UNARY EXPRESSION_4 EXPRESSION_EQUALS
EXPRESSION_EQUALS	::=	/= UNARY EXPRESSION_4 EXPRESSION_EQUALS
EXPRESSION_EQUALS	::=	''

EXPRESSION_4	::=	EXPRESSION_5 EXPRESSION_COMPARAISON
EXPRESSION_COMPARAISON	::=	> UNARY EXPRESSION_5 EXPRESSION_COMPARAISON
EXPRESSION_COMPARAISON	::=	>= UNARY EXPRESSION_5 EXPRESSION_COMPARAISON
EXPRESSION_COMPARAISON	::=	< UNARY EXPRESSION_5 EXPRESSION_COMPARAISON
EXPRESSION_COMPARAISON	::=	<= UNARY EXPRESSION_5 EXPRESSION_COMPARAISON
EXPRESSION_COMPARAISON	::=	''

EXPRESSION_5	::=	EXPRESSION_6 EXPRESSION_PLUS_MOINS
EXPRESSION_PLUS_MOINS	::=	+ UNARY EXPRESSION_6 EXPRESSION_PLUS_MOINS
EXPRESSION_PLUS_MOINS	::=	- UNARY EXPRESSION_6 EXPRESSION_PLUS_MOINS
EXPRESSION_PLUS_MOINS	::=	''

EXPRESSION_6	::=	EXPRESSION_7 EXPRESSION_MULT_DIV
EXPRESSION_MULT_DIV	::=	* UNARY EXPRESSION_7 EXPRESSION_MULT_DIV
EXPRESSION_MULT_DIV	::=	/ UNARY EXPRESSION_7 EXPRESSION_MULT_DIV
EXPRESSION_MULT_DIV	::=	rem UNARY EXPRESSION_7 EXPRESSION_MULT_DIV
EXPRESSION_MULT_DIV	::=	''

EXPRESSION_7	::=	EXPRESSION_ATOMS EXPRESSION_ACCESS_IDENT
EXPRESSION_ACCESS_IDENT	::=	. ident EXPRESSION_ACCESS_IDENT
EXPRESSION_ACCESS_IDENT	::=	''

EXPRESSION_ATOMS	::=	entier
EXPRESSION_ATOMS	::=	caractere
EXPRESSION_ATOMS	::=	ident START_NEW_EXPRESSION
EXPRESSION_ATOMS	::=	true
EXPRESSION_ATOMS	::=	false
EXPRESSION_ATOMS	::=	null
EXPRESSION_ATOMS	::=	( UNARY EXPRESSION )

UNARY	::=	- UNARY
UNARY	::=	''
START_NEW_EXPRESSION	::=	( UNARY GENERATE_EXPRESSION
START_NEW_EXPRESSION	::=	''

GENERATE_EXPRESSION	::=	EXPRESSION END_GENERATE_EXPRESSION
END_GENERATE_EXPRESSION	::=	)
END_GENERATE_EXPRESSION	::=	, UNARY GENERATE_EXPRESSION

INSTRUCTION	::=	ident INSTRUCTION_IDENT_EXPRESSION
INSTRUCTION	::=	WI_EXPRESSION := UNARY EXPRESSION ;
INSTRUCTION	::=	return END_RETURN
INSTRUCTION	::=	begin GENERATE_INSTRUCTIONS end ;
INSTRUCTION	::=	if UNARY EXPRESSION then GENERATE_INSTRUCTIONS NEXT_IF
INSTRUCTION	::=	for ident in FOR_INSTRUCTION
INSTRUCTION	::=	while UNARY EXPRESSION loop GENERATE_INSTRUCTIONS end loop ;

INSTRUCTION_IDENT_EXPRESSION	::= INSTRUCTION_IDENT_EXPRESSION1
INSTRUCTION_IDENT_EXPRESSION	::= INSTRUCTION_IDENT_EXPRESSION2

INSTRUCTION_IDENT_EXPRESSION1	::=	:= UNARY EXPRESSION ;
INSTRUCTION_IDENT_EXPRESSION1	::=	;
INSTRUCTION_IDENT_EXPRESSION1 ::= .  ident INSTRUCTION_IDENT_EXPRESSION1

INSTRUCTION_IDENT_EXPRESSION2	::=	( UNARY GENERATE_EXPRESSION INSTRUCTION_IDENT_EXPRESSION1

END_RETURN	::=	;
END_RETURN	::=	UNARY EXPRESSION ;

FOR_INSTRUCTION	::=	UNARY EXPRESSION .. UNARY EXPRESSION loop GENERATE_INSTRUCTIONS end loop ;
FOR_INSTRUCTION	::=	reverse UNARY EXPRESSION .. UNARY EXPRESSION loop GENERATE_INSTRUCTIONS end loop ;

NEXT_IF	::=	end if ;
NEXT_IF	::=	else ELSE
NEXT_IF	::=	elsif ELSIF
ELSE	::=	GENERATE_INSTRUCTIONS end if ;
ELSIF	::=	UNARY EXPRESSION then GENERATE_INSTRUCTIONS END_ELSIF
END_ELSIF	::=	end if ;
END_ELSIF	::=	elsif ELSIF
END_ELSIF	::=	else ELSE

WI_EXPRESSION	::=	WI_EXPRESSION_1 WI_EXPRESSION_OR
WI_EXPRESSION	::=	new ident WI_EXPRESSION_OR
WI_EXPRESSION	::=	character’val ( UNARY EXPRESSION ) WI_EXPRESSION_OR

WI_EXPRESSION_OR	::=	or UNARY WI_EXPRESSION_ELSE
WI_EXPRESSION_OR	::=	''
WI_EXPRESSION_ELSE	::=	WI_EXPRESSION_1 WI_EXPRESSION_OR
WI_EXPRESSION_ELSE	::=	else UNARY WI_EXPRESSION_1 WI_EXPRESSION_OR

WI_EXPRESSION_1	::=	WI_EXPRESSION_NOT WI_EXPRESSION_AND
WI_EXPRESSION_AND	::=	and UNARY WI_EXPRESSION_THEN
WI_EXPRESSION_AND	::=	''
WI_EXPRESSION_THEN	::=	WI_EXPRESSION_NOT WI_EXPRESSION_AND
WI_EXPRESSION_THEN	::=	then UNARY WI_EXPRESSION_NOT WI_EXPRESSION_AND

WI_EXPRESSION_NOT	::=	not UNARY WI_EXPRESSION_NOT
WI_EXPRESSION_NOT	::=	WI_EXPRESSION_3

WI_EXPRESSION_3	::=	WI_EXPRESSION_4 WI_EXPRESSION_EQUALS
WI_EXPRESSION_EQUALS	::=	= UNARY WI_EXPRESSION_4 WI_EXPRESSION_EQUALS
WI_EXPRESSION_EQUALS	::=	/= UNARY WI_EXPRESSION_4 WI_EXPRESSION_EQUALS
WI_EXPRESSION_EQUALS	::=	''

WI_EXPRESSION_4	::=	WI_EXPRESSION_5 WI_EXPRESSION_COMPARAISON
WI_EXPRESSION_COMPARAISON	::=	> UNARY WI_EXPRESSION_5 WI_EXPRESSION_COMPARAISON
WI_EXPRESSION_COMPARAISON	::=	>= UNARY WI_EXPRESSION_5 WI_EXPRESSION_COMPARAISON
WI_EXPRESSION_COMPARAISON	::=	< UNARY WI_EXPRESSION_5 WI_EXPRESSION_COMPARAISON
WI_EXPRESSION_COMPARAISON	::=	<= UNARY WI_EXPRESSION_5 WI_EXPRESSION_COMPARAISON
WI_EXPRESSION_COMPARAISON	::=	''

WI_EXPRESSION_5	::=	WI_EXPRESSION_6 WI_EXPRESSION_PLUS_MOINS
WI_EXPRESSION_PLUS_MOINS	::=	+ UNARY WI_EXPRESSION_6 WI_EXPRESSION_PLUS_MOINS
WI_EXPRESSION_PLUS_MOINS	::=	- UNARY WI_EXPRESSION_6 WI_EXPRESSION_PLUS_MOINS
WI_EXPRESSION_PLUS_MOINS	::=	''

WI_EXPRESSION_6	::=	WI_EXPRESSION_ACCES_IDENT WI_EXPRESSION_MUL_DIV
WI_EXPRESSION_MUL_DIV	::=	* UNARY WI_EXPRESSION_ACCES_IDENT WI_EXPRESSION_MUL_DIV
WI_EXPRESSION_MUL_DIV	::=	/ UNARY WI_EXPRESSION_ACCES_IDENT WI_EXPRESSION_MUL_DIV
WI_EXPRESSION_MUL_DIV	::=	rem UNARY WI_EXPRESSION_ACCES_IDENT WI_EXPRESSION_MUL_DIV
WI_EXPRESSION_MUL_DIV	::=	''

WI_EXPRESSION_ACCES_IDENT	::=	WI_EXPRESSION_ATOMS EXPRESSION_ACCESS_IDENT

WI_EXPRESSION_ATOMS	::=	entier
WI_EXPRESSION_ATOMS	::=	caractere
WI_EXPRESSION_ATOMS	::=	( UNARY GENERATE_EXPRESSION
WI_EXPRESSION_ATOMS	::=	true
WI_EXPRESSION_ATOMS	::=	false
WI_EXPRESSION_ATOMS	::=	null
